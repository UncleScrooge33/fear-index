<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>World Feeling</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
  :root{ --bg:#0f1220; --panel:#161a2b; --text:#e8ecf1; --muted:#9aa3b2; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:1100px;margin:28px auto 40px;padding:0 16px}

  .hero{display:flex;flex-direction:column;align-items:center;text-align:center;gap:6px;margin-bottom:20px}
  .title{font-size:40px;line-height:1.15;margin:0;font-weight:700;letter-spacing:.2px}
  .avg{font-size:28px;font-weight:700;letter-spacing:.3px}
  .desc{color:var(--muted);font-size:15px;margin-top:2px}
  .timer{color:var(--muted);font-size:13px;margin-top:2px}
  .spacer{height:10px}

  .card{background:var(--panel);border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:16px}
  .chartRow{display:grid;grid-template-columns:120px 1fr;gap:12px}
  .scale{display:flex;flex-direction:column;gap:8px}
  .scale button{background:transparent;border:1px solid rgba(255,255,255,.1);color:var(--text);padding:10px 12px;border-radius:10px;cursor:pointer;text-align:left}
  .scale button.active{border-color:#7dd3fc;box-shadow:0 0 0 1px rgba(125,211,252,.25) inset}
  canvas{width:100%;height:380px}

  .sliderCard{margin-top:16px}
  .sliderBox{display:grid;grid-template-columns:1fr auto;gap:12px;align-items:center}
  .valueBadge{min-width:64px;text-align:center;padding:10px 12px;border:1px solid rgba(255,255,255,.1);border-radius:10px}
  .voteRow{display:flex;gap:12px;margin-top:12px;align-items:center;flex-wrap:wrap}
  .voteBtn{background:linear-gradient(90deg,#39486a,#3c6b7b);border:0;color:#fff;padding:12px 16px;border-radius:12px;cursor:pointer;transition:.2s opacity}
  .voteBtn.disabled{opacity:.5;cursor:not-allowed;filter:grayscale(30%)}
  .muted{color:#9aa3b2}.ok{color:#22c55e}

  .infoCard{margin-top:16px}
  .infoTitle{margin:0 0 10px;font-size:18px;font-weight:700}
  .infoText{color:var(--muted);font-size:14px;line-height:1.55;margin:0}

  @media (max-width:820px){
    .chartRow{grid-template-columns:1fr}
    .scale{flex-direction:row; overflow:auto}
    .scale button{text-align:center;flex:1;white-space:nowrap}
    .title{font-size:34px}
    .avg{font-size:24px}
  }

  input[type="range"]{-webkit-appearance:none;appearance:none;width:100%;height:12px;background:linear-gradient(90deg,#ef4444 0%, #eab308 50%, #166534 100%);border-radius:999px;outline:none}
  input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:22px;height:22px;border-radius:50%;background:#fff;border:2px solid #0f1220;box-shadow:0 0 0 3px rgba(255,255,255,.2)}
  input[type="range"]::-moz-range-thumb{width:22px;height:22px;border-radius:50%;background:#fff;border:2px solid #0f1220}

  .policyBtn{
  display:inline-block;
  padding:12px 24px;
  border-radius:12px;
  background:linear-gradient(90deg,#39486a,#3c6b7b);
  color:#e8ecf1;
  text-decoration:none;
  font-weight:600;
  transition:background .2s,opacity .2s;
}
.policyBtn:hover{
  background:linear-gradient(90deg,#3c6b7b,#39486a);
  opacity:0.9;
}

</style>
</head>
<body>
<div class="wrap">

  <div class="hero">
    <h1 class="title">World Feeling</h1>
    <div id="avg" class="avg">-- / 100</div>
    <div class="desc">Curve representing humanity’s global fear/hope sentiment across the world.</div>
    <div id="nextTimer" class="timer">Next update in —</div>
  </div>
  <div class="spacer"></div>

  <div class="card chartRow">
    <div class="scale">
      <button data-tf="1H" class="active">1H</button>
      <button data-tf="1D">1D</button>
      <button data-tf="7D">7D</button>
      <button data-tf="1M">1M</button>
      <button data-tf="90D">90D</button>
      <button data-tf="1Y">1Y</button>
    </div>
    <div><canvas id="chart"></canvas></div>
  </div>

  <div class="card sliderCard">
    <div class="sliderBox">
      <input id="slider" type="range" min="0" max="100" value="50" step="1" />
      <div class="valueBadge"><span id="sVal">50</span>/100</div>
    </div>
    <div class="voteRow">
      <form name="vote" method="POST" data-netlify="true" netlify-honeypot="bot-field" hidden>
        <input type="hidden" name="form-name" value="vote"/>
        <input type="text" name="value" id="voteValue"/>
        <input type="text" name="bot-field"/>
      </form>
      <button class="voteBtn" id="voteBtn">Vote</button>
      <span id="msg" class="muted"></span>
    </div>
  </div>

  <!-- ===== Info block (bottom) ===== -->
  <div class="card infoCard">
    <h3 class="infoTitle">What this index shows</h3>
    <p class="infoText">
      The index aggregates community votes into fixed time buckets (1H: 1 min · 1D: 30 min · 7D: 8 h · 1M: 1 day · 90D: 3 days · 1Y: 2 weeks).
      Each bucket’s mean is 50 if no votes occur (so the curve drifts back to neutral when activity stops).
      Every plotted point is a moving average of the last 5 bucket means, computed once when each bucket closes — previous points never change.
      Hover a point to see its exact value and how many votes it includes. You can vote once every 12 hours using the slider above.
    </p>
  </div>

</div>

<script>
  /* ===== Colors ===== */
  function lerp(a,b,t){ return a + (b-a)*t; }
  function hexToRgb(h){ const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h); return m?{r:parseInt(m[1],16),g:parseInt(m[2],16),b:parseInt(m[3],16)}:null; }
  function rgbToHex({r,g,b}){ const h=x=>x.toString(16).padStart(2,'0'); return `#${h(r)}${h(g)}${h(b)}`; }
  function blend(c1,c2,t){ const a=hexToRgb(c1), b=hexToRgb(c2); return rgbToHex({r:Math.round(lerp(a.r,b.r,t)), g:Math.round(lerp(a.g,b.g,t)), b:Math.round(lerp(a.b,b.b,t))}); }
  function valToColor(v){
    v = Math.max(0, Math.min(100, v));
    if (v<=50){ return blend('#ef4444','#eab308', v/50); }
    return blend('#eab308','#166534', (v-50)/50);
  }

  /* ===== Chart ===== */
  const ctx = document.getElementById('chart');
  const chart = new Chart(ctx, {
    type: 'line',
    data: { labels: [], datasets: [{
      label: 'Fear/Hope',
      data: [],
      _counts: [],
      borderWidth: 3,
      pointRadius: 0,
      tension: .35,
      segment: {
        borderColor: ctx => {
          const y0 = ctx.p0?.parsed?.y, y1 = ctx.p1?.parsed?.y;
          const mid = ((y0??50)+(y1??50))/2;
          return valToColor(mid);
        }
      },
      borderColor: '#888',
      fill: false
    }]},
    options: {
      responsive:true,
      plugins:{
        legend:{display:false},
        tooltip:{
          mode:'index', intersect:false,
          callbacks:{
            label: (tt) => {
              const v = tt.parsed.y?.toFixed(1) ?? '--';
              const ds = tt.chart.data.datasets[tt.datasetIndex];
              const n = ds?._counts?.[tt.dataIndex] ?? 0;
              return `Value: ${v}  |  Votes: ${n}`;
            }
          }
        }
      },
      interaction:{ mode:'index', intersect:false },
      scales:{
        y:{ min:0, max:100, grid:{color:'rgba(255,255,255,.06)'} },
        x:{
          grid:{color:'rgba(255,255,255,.06)', drawOnChartArea:false},
          ticks:{ autoSkip:false, callback:(val, idx)=> (idx % window.__tickStep === 0 ? chart.data.labels[idx] : '') }
        }
      }
    }
  });

  /* ===== Default timeframe = 1H ===== */
  const tfButtons = Array.from(document.querySelectorAll('.scale button'));
  let timeframe = '1H';
  tfButtons.forEach(b=>b.classList.remove('active'));
  document.querySelector('.scale button[data-tf="1H"]').classList.add('active');

  function pickTickStep(tf){
    if (tf==='1H')  return 5;
    if (tf==='1D')  return 4;
    if (tf==='7D')  return 3;
    if (tf==='1M')  return 3;
    if (tf==='90D') return 3;
    if (tf==='1Y')  return 2;
    return 4;
  }
  window.__tickStep = pickTickStep(timeframe);

  /* ===== Scheduler & Next-update timer ===== */
  let nextTimer = null, countdownInterval = null, nextAtTs = 0;

  function fmtTimer(ms){
    if (ms < 0) ms = 0;
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60), ss = String(s % 60).padStart(2,'0');
    return `${m}:${ss}`;
  }
  function renderCountdown(){
    if (!nextAtTs) return;
    const left = nextAtTs - Date.now();
    document.getElementById('nextTimer').textContent = `Next update in ${fmtTimer(left)}`;
  }
  function scheduleNext(meta){
    if (nextTimer) clearTimeout(nextTimer);
    if (countdownInterval) clearInterval(countdownInterval);

    const step = meta?.stepMs ?? 60000;
    // meta.end = dernier bucket TERMINÉ (= alignedNow - step)
    // prochaine fermeture = alignedNow + step = meta.end + 2*step
    let nextAt = (meta?.end ?? Date.now()) + 2 * step;

    // si c'est déjà passé (latence), saute par pas jusqu'au futur
    const now = Date.now();
    if (nextAt <= now) {
      const missed = Math.floor((now - nextAt) / step) + 1;
      nextAt += missed * step;
    }

    nextAtTs = nextAt;
    renderCountdown();
    countdownInterval = setInterval(renderCountdown, 1000);

    const delay = Math.max(250, nextAt - now);
    nextTimer = setTimeout(() => refresh(), delay);
  }

  tfButtons.forEach(b=>b.addEventListener('click', ()=>{
    tfButtons.forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    timeframe = b.dataset.tf;
    if (nextTimer) clearTimeout(nextTimer);
    if (countdownInterval) clearInterval(countdownInterval);
    window.__tickStep = pickTickStep(timeframe);
    refresh();
  }));

  /* ===== Fetch & bind ===== */
  async function refresh(){
    const url = '/.netlify/functions/read-votes?tf=' + timeframe;
    const r = await fetch(url, { cache:'no-store' });
    const j = await r.json();

    window.__tickStep = pickTickStep(timeframe);
    chart.data.labels  = j.points.map(p=>p.t);
    chart.data.datasets[0].data    = j.points.map(p=>p.v);
    chart.data.datasets[0]._counts = j.points.map(p=>p.n);
    chart.update();

    const current = (j.current ?? 50);
    const avgEl = document.getElementById('avg');
    avgEl.textContent = `${current} / 100`;
    avgEl.style.color = valToColor(current);

    scheduleNext(j.meta);
  }

  /* ===== Slider + cooldown 12h ===== */
  const slider = document.getElementById('slider');
  const sVal = document.getElementById('sVal');
  function setBadge(v){
    sVal.textContent = v;
    const badge = document.querySelector('.valueBadge');
    const c = valToColor(Number(v));
    badge.style.borderColor = c + '55';
    badge.style.color = c;
  }
  setBadge(50);
  slider.addEventListener('input', e=> setBadge(e.target.value));

  const COOLDOWN_MIN = 12*60; // 12h
  const msg = document.getElementById('msg');
  const btn = document.getElementById('voteBtn');

  function remainMs(){
    const last = Number(localStorage.getItem('lastVoteTs')||0);
    return Math.max(0, (last + COOLDOWN_MIN*60*1000) - Date.now());
  }
  function fmtCooldown(ms){
    const m = Math.ceil(ms/60000);
    if (m >= 60) { const h = Math.floor(m/60), mm = m%60; return `${h}h ${mm}m`; }
    return `${m} min`;
  }
  function updateCooldownUI(){
    const left = remainMs();
    if (left > 0){
      btn.disabled = true; btn.classList.add('disabled');
      msg.className='muted'; msg.textContent = `Next vote in ${fmtCooldown(left)}`;
    }else{
      btn.disabled = false; btn.classList.remove('disabled');
      msg.className='muted'; msg.textContent = '';
    }
  }
  setInterval(updateCooldownUI, 1000); updateCooldownUI();

  async function voteOnce(value){
    const data = new FormData();
    data.append('form-name','vote');
    data.append('value', String(value));
    await fetch('/', { method:'POST', body:data });
  }

  async function vote(){
    if (remainMs() > 0) return;
    btn.disabled = true; btn.classList.add('disabled'); btn.textContent = 'Voted ✓';
    const val = Number(slider.value);
    await voteOnce(val);
    localStorage.setItem('lastVoteTs', Date.now().toString());
    msg.className='ok'; msg.textContent = 'Thanks for voting!';
    setTimeout(()=>{ msg.className='muted'; msg.textContent=''; updateCooldownUI(); }, 1500);
    // pas de refresh ici : la courbe bouge au prochain tick planifié
  }
  btn.addEventListener('click', vote);

  // First draw
  refresh();
</script>

<!-- === Privacy Policy button === -->
<div class="card" style="margin-top:24px;text-align:center">
  <a href="/privacy.html"
     class="policyBtn">Privacy Policy</a>
</div>


</body>
</html>
