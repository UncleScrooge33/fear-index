<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Humanity Fear Index</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
  :root{
    --bg:#0f1220; --panel:#161a2b; --text:#e8ecf1; --muted:#9aa3b2; --accent:#7dd3fc;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:1100px;margin:28px auto 40px;padding:0 16px}

  /* ===== HERO ===== */
  .hero{display:flex;flex-direction:column;align-items:center;text-align:center;gap:8px;margin-bottom:20px}
  .title{font-size:40px;line-height:1.15;margin:0;font-weight:700;letter-spacing:.2px}
  .avg{font-size:28px;font-weight:700;letter-spacing:.3px}
  .desc{color:var(--muted);font-size:15px;margin-top:4px}
  .spacer{height:10px}

  /* ===== CARDS / LAYOUT ===== */
  .card{background:var(--panel);border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:16px}
  .chartRow{display:grid;grid-template-columns:120px 1fr;gap:12px}
  .scale{display:flex;flex-direction:column;gap:8px}
  .scale button{
    background:transparent;border:1px solid rgba(255,255,255,.1);color:var(--text);
    padding:10px 12px;border-radius:10px;cursor:pointer;text-align:left
  }
  .scale button.active{border-color:#7dd3fc;box-shadow:0 0 0 1px rgba(125,211,252,.25) inset}
  canvas{width:100%;height:380px}

  .sliderCard{margin-top:16px}
  .sliderBox{display:grid;grid-template-columns:1fr auto;gap:12px;align-items:center}
  .valueBadge{min-width:64px;text-align:center;padding:10px 12px;border:1px solid rgba(255,255,255,.1);border-radius:10px}
  .voteRow{display:flex;gap:12px;margin-top:12px;align-items:center;flex-wrap:wrap}
  .voteBtn{background:linear-gradient(90deg,#39486a,#3c6b7b);border:0;color:#fff;padding:12px 16px;border-radius:12px;cursor:pointer;transition:.2s opacity}
  .voteBtn.disabled{opacity:.5;cursor:not-allowed;filter:grayscale(30%)}
  .muted{color:#9aa3b2}.ok{color:#22c55e}
  .dev{margin-left:auto;display:none}
  .dev button{margin-left:8px;border:1px solid rgba(255,255,255,.1);background:transparent;color:#e8ecf1;padding:8px 10px;border-radius:10px;cursor:pointer}

  @media (max-width:820px){
    .chartRow{grid-template-columns:1fr}
    .scale{flex-direction:row; overflow:auto}
    .scale button{text-align:center;flex:1;white-space:nowrap}
    .title{font-size:34px}
    .avg{font-size:24px}
  }

  /* Slider */
  input[type="range"]{-webkit-appearance:none;appearance:none;width:100%;height:12px;background:linear-gradient(90deg,#ef4444 0%, #eab308 50%, #166534 100%);border-radius:999px;outline:none}
  input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:22px;height:22px;border-radius:50%;background:#fff;border:2px solid #0f1220;box-shadow:0 0 0 3px rgba(255,255,255,.2)}
  input[type="range"]::-moz-range-thumb{width:22px;height:22px;border-radius:50%;background:#fff;border:2px solid #0f1220}
</style>
</head>
<body>
<div class="wrap">

  <!-- ===== HERO ===== -->
  <div class="hero">
    <h1 class="title">Humanity Fear Index</h1>
    <div id="avg" class="avg">33 / 100</div>
    <div class="desc">Average of community votes over the selected period.</div>
  </div>
  <div class="spacer"></div>

  <!-- ===== CHART ===== -->
  <div class="card chartRow">
    <div class="scale">
      <button data-tf="1H" class="active">1H</button>
      <button data-tf="1D">1D</button>
      <button data-tf="7D">7D</button>
      <button data-tf="90D">90D</button>
      <button data-tf="1Y">1Y</button>
    </div>
    <div><canvas id="chart"></canvas></div>
  </div>

  <!-- ===== SLIDER / VOTE ===== -->
  <div class="card sliderCard">
    <div class="sliderBox">
      <input id="slider" type="range" min="0" max="100" value="50" step="1" />
      <div class="valueBadge"><span id="sVal">50</span>/100</div>
    </div>
    <div class="voteRow">
      <!-- Hidden Netlify Form -->
      <form name="vote" method="POST" data-netlify="true" netlify-honeypot="bot-field" hidden>
        <input type="hidden" name="form-name" value="vote"/>
        <input type="text" name="value" id="voteValue"/>
        <input type="text" name="bot-field"/>
      </form>
      <button class="voteBtn" id="voteBtn">Vote</button>
      <span id="msg" class="muted"></span>

      <!-- Dev tools (show with ?dev=1) -->
      <div class="dev" id="devBox">
        <span class="muted">DEV:</span>
        <button id="devStart">Start random spam</button>
        <button id="devStop">Stop</button>
      </div>
    </div>
  </div>
</div>

<script>
  /* ===== Color mapping (0→red, 50→yellow, 100→dark green) ===== */
  function lerp(a,b,t){ return a + (b-a)*t; }
  function hexToRgb(h){ const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h); return m?{r:parseInt(m[1],16),g:parseInt(m[2],16),b:parseInt(m[3],16)}:null; }
  function rgbToHex({r,g,b}){ const h=x=>x.toString(16).padStart(2,'0'); return `#${h(r)}${h(g)}${h(b)}`; }
  function blend(c1,c2,t){ const a=hexToRgb(c1), b=hexToRgb(c2); return rgbToHex({r:Math.round(lerp(a.r,b.r,t)), g:Math.round(lerp(a.g,b.g,t)), b:Math.round(lerp(a.b,b.b,t))}); }
  function valToColor(v){
    v = Math.max(0, Math.min(100, v));
    if (v<=50){ return blend('#ef4444','#eab308', v/50); }        // red → yellow
    return blend('#eab308','#166534', (v-50)/50);                 // yellow → dark green
  }

  /* ===== Chart config ===== */
  const ctx = document.getElementById('chart');
  const chart = new Chart(ctx, {
    type: 'line',
    data: { labels: [], datasets: [{
      label: 'Fear Index',
      data: [],
      borderWidth: 3,
      pointRadius: 0,
      tension: .35,
      // Couleur par SEGMENT selon la valeur (dégradé le long de la courbe)
      segment: {
        borderColor: ctx => {
          const y0 = ctx.p0?.parsed?.y, y1 = ctx.p1?.parsed?.y;
          const mid = ( (y0??50) + (y1??50) ) / 2;
          return valToColor(mid);
        }
      },
      borderColor: '#888', // fallback
      fill: false          // pas de zone bleue en dessous
    }]},
    options: {
      responsive:true,
      plugins:{ legend:{display:false}, tooltip:{mode:'index', intersect:false} },
      interaction:{ mode:'index', intersect:false },
      scales:{
        y:{ min:0, max:100, grid:{color:'rgba(255,255,255,.06)'} },
        x:{
          grid:{color:'rgba(255,255,255,.06)', drawOnChartArea:false},
          ticks:{
            autoSkip:false,
            callback:(val, idx)=> (idx % window.__tickStep === 0 ? chart.data.labels[idx] : '')
          }
        }
      }
    }
  });

  /* ===== Timeframe & ticks ===== */
  const tfButtons = Array.from(document.querySelectorAll('.scale button'));
  let timeframe = '1D';
  window.__tickStep = 12;

  function pickTickStep(tf){
    if (tf==='1H')  return 5;  // label every 5 min
    if (tf==='1D')  return 4;  // label every 2 h (30 min buckets)
    if (tf==='7D')  return 3;  // label every 24 h (8 h buckets)
    if (tf==='90D') return 3;  // ~every 7 days (3 d buckets)
    if (tf==='1Y')  return 2;  // ~every 4 weeks (2 w buckets)
    return 4;
  }

  /* ===== Scheduler: refresh only at bucket boundaries ===== */
  let nextTimer = null;
  function scheduleNext(meta){
    if (nextTimer) clearTimeout(nextTimer);
    const nextAt = (meta?.end ?? Date.now()) + (meta?.stepMs ?? 60000);
    const delay = Math.max(250, nextAt - Date.now());
    nextTimer = setTimeout(() => refresh(), delay);
  }

  tfButtons.forEach(b=>b.addEventListener('click', ()=>{
    tfButtons.forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    timeframe = b.dataset.tf;
    if (nextTimer) clearTimeout(nextTimer);
    window.__tickStep = pickTickStep(timeframe);
    refresh();
  }));

  /* ===== Data fetching ===== */
  async function refresh(){
    const params = new URLSearchParams(location.search);
    const devMode = params.get('dev') === '1';
    const url = '/.netlify/functions/read-votes?tf=' + timeframe + (devMode ? '&includeSpam=1' : '');
    const r = await fetch(url, { cache:'no-store' });
    const j = await r.json();

    window.__tickStep = pickTickStep(timeframe);
    chart.data.labels = j.points.map(p=>p.t);
    chart.data.datasets[0].data = j.points.map(p=>p.v);
    chart.update();

    // Header: moyenne colorée
    const current = (j.current ?? 50);
    const avgEl = document.getElementById('avg');
    avgEl.textContent = `${current} / 100`;
    avgEl.style.color = valToColor(current);

    // programme la prochaine MAJ pile à la fin du prochain bucket
    scheduleNext(j.meta);
  }

  /* ===== Slider + color badge ===== */
  const slider = document.getElementById('slider');
  const sVal = document.getElementById('sVal');
  function setBadge(v){
    sVal.textContent = v;
    const badge = document.querySelector('.valueBadge');
    const c = valToColor(Number(v));
    badge.style.borderColor = c + '55';
    badge.style.color = c;
  }
  setBadge(50);
  slider.addEventListener('input', e=> setBadge(e.target.value));

  /* ===== Vote (no chart refresh here) ===== */
  const msg = document.getElementById('msg');
  const btn = document.getElementById('voteBtn');

  async function voteOnce(value){
    const data = new FormData();
    data.append('form-name','vote');
    data.append('value', String(value));
    await fetch('/', { method:'POST', body:data });
  }

  async function vote(){
    btn.disabled = true; btn.classList.add('disabled'); btn.textContent = 'Voted ✓';
    const val = Number(slider.value);
    await voteOnce(val);
    msg.className='ok'; msg.textContent='Thanks for voting!';
    setTimeout(()=>{ msg.className='muted'; msg.textContent=''; btn.disabled=false; btn.classList.remove('disabled'); btn.textContent='Vote'; }, 1200);
    // Pas de refresh : la courbe bougera au prochain tick programmé
  }
  btn.addEventListener('click', vote);

  /* ===== Dev spam (15–20 votes/sec) ===== */
  const devBox = document.getElementById('devBox');
  let spamTimer = null;
  if (new URLSearchParams(location.search).get('dev') === '1') devBox.style.display = 'flex';

  document.getElementById('devStart')?.addEventListener('click', ()=>{
    if (spamTimer) return;
    spamTimer = setInterval(async ()=>{
      for (let i=0;i<Math.floor(1 + Math.random()*3);i++){
        const v = Math.floor(5 + Math.random()*90);
        voteOnce(v).catch(()=>{});
      }
    }, 60);
  });
  document.getElementById('devStop')?.addEventListener('click', ()=>{
    clearInterval(spamTimer); spamTimer = null;
  });

  // First draw + schedule
  refresh();
</script>
</body>
</html>
