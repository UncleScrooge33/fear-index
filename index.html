<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Humanity Fear Index</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
  :root{ --bg:#0f1220; --panel:#161a2b; --text:#e8ecf1; --muted:#9aa3b2; --accent:#7dd3fc; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:1100px;margin:24px auto;padding:0 16px}
  h1{margin:0 0 8px;font-size:24px}
  .sub{color:var(--muted);margin:0 0 16px}
  .card{background:var(--panel);border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:16px}
  .chartRow{display:grid;grid-template-columns:120px 1fr;gap:12px}
  .scale{display:flex;flex-direction:column;gap:8px}
  .scale button{background:transparent;border:1px solid rgba(255,255,255,.1);color:var(--text);padding:8px 10px;border-radius:10px;cursor:pointer;text-align:left}
  .scale button.active{border-color:var(--accent);box-shadow:0 0 0 1px rgba(125,211,252,.25) inset}
  canvas{width:100%;height:380px}
  .sliderCard{margin-top:14px}
  .sliderBox{display:grid;grid-template-columns:1fr auto;gap:12px;align-items:center}
  .valueBadge{min-width:56px;text-align:center;padding:10px 12px;border:1px solid rgba(255,255,255,.1);border-radius:10px}
  .voteRow{display:flex;gap:12px;margin-top:12px;align-items:center;flex-wrap:wrap}
  .voteBtn{background:linear-gradient(90deg,#39486a,#3c6b7b);border:0;color:#fff;padding:12px 16px;border-radius:12px;cursor:pointer;transition:.2s opacity}
  .voteBtn.disabled{opacity:.5;cursor:not-allowed;filter:grayscale(30%)}
  .muted{color:#9aa3b2}.ok{color:#22c55e}
  .dev{margin-left:auto;display:none}
  .dev button{margin-left:8px;border:1px solid rgba(255,255,255,.1);background:transparent;color:#e8ecf1;padding:8px 10px;border-radius:10px;cursor:pointer}
  @media (max-width:820px){ .chartRow{grid-template-columns:1fr} .scale{flex-direction:row; overflow:auto} .scale button{text-align:center;flex:1} }
  input[type="range"]{-webkit-appearance:none;appearance:none;width:100%;height:12px;background:linear-gradient(90deg,#ef4444 0%, #eab308 50%, #22c55e 100%);border-radius:999px;outline:none}
  input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:22px;height:22px;border-radius:50%;background:#fff;border:2px solid #0f1220;box-shadow:0 0 0 3px rgba(255,255,255,.2)}
  input[type="range"]::-moz-range-thumb{width:22px;height:22px;border-radius:50%;background:#fff;border:2px solid #0f1220}
</style>
</head>
<body>
<div class="wrap">
  <h1>Humanity Fear Index <span id="current" class="muted"></span></h1>
  <p class="sub">Average of community votes over the selected period.</p>

  <div class="card chartRow">
    <div class="scale">
      <button data-tf="1H" class="active">1H</button>
      <button data-tf="1D">1D</button>
      <button data-tf="7D">7D</button>
      <button data-tf="90D">90D</button>
      <button data-tf="1Y">1Y</button>
    </div>
    <div><canvas id="chart"></canvas></div>
  </div>

  <div class="card sliderCard">
    <div class="sliderBox">
      <input id="slider" type="range" min="0" max="100" value="50" step="1" />
      <div class="valueBadge"><span id="sVal">50</span>/100</div>
    </div>
    <div class="voteRow">
      <!-- Hidden Netlify Form -->
      <form name="vote" method="POST" data-netlify="true" netlify-honeypot="bot-field" hidden>
        <input type="hidden" name="form-name" value="vote"/>
        <input type="text" name="value" id="voteValue"/>
        <input type="text" name="bot-field"/>
      </form>
      <button class="voteBtn" id="voteBtn">Vote</button>
      <span id="msg" class="muted"></span>

      <!-- Dev tools (show with ?dev=1) -->
      <div class="dev" id="devBox">
        <span class="muted">DEV:</span>
        <button id="devStart">Start random spam</button>
        <button id="devStop">Stop</button>
      </div>
    </div>
  </div>
</div>

<script>
  /* ===== Chart config ===== */
  const ctx = document.getElementById('chart');
  const chart = new Chart(ctx, {
    type: 'line',
    data: { labels: [], datasets: [{
      label: 'Fear Index',
      data: [],
      borderWidth: 2,
      pointRadius: 0,
      tension: .35,              // lissage visuel entre points (pas de recalcul)
      borderColor: '#7dd3fc',
      fill: true,
      backgroundColor: (ctx)=>{
        const {chart} = ctx; const {ctx:c} = chart;
        const g = c.createLinearGradient(0,0,0,chart.height);
        g.addColorStop(0, 'rgba(125,211,252,.25)');
        g.addColorStop(1, 'rgba(125,211,252,0)');
        return g;
      }
    }]},
    options: {
      responsive:true,
      plugins:{ legend:{display:false}, tooltip:{mode:'index', intersect:false} },
      interaction:{ mode:'index', intersect:false },
      scales:{
        y:{ min:0, max:100, grid:{color:'rgba(255,255,255,.06)'} },
        x:{
          grid:{color:'rgba(255,255,255,.06)', drawOnChartArea:false},
          ticks:{
            autoSkip:false,
            callback:(val, idx)=> (idx % window.__tickStep === 0 ? chart.data.labels[idx] : '')
          }
        }
      }
    }
  });

  /* ===== Timeframe & ticks ===== */
  const tfButtons = Array.from(document.querySelectorAll('.scale button'));
  let timeframe = '1D';
  window.__tickStep = 12;

  function pickTickStep(tf){
    if (tf==='1H')  return 5;  // label every 5 min
    if (tf==='1D')  return 4;  // label every 2 h (30 min buckets)
    if (tf==='7D')  return 3;  // label every 24 h (8 h buckets)
    if (tf==='90D') return 3;  // ~every 7 days (3 d buckets)
    if (tf==='1Y')  return 2;  // ~every 4 weeks (2 w buckets)
    return 4;
  }

  /* ===== Scheduler: refresh only at bucket boundaries ===== */
  let nextTimer = null;
  function scheduleNext(meta){
    if (nextTimer) clearTimeout(nextTimer);
    // next point = end of next bucket
    const nextAt = (meta?.end ?? Date.now()) + (meta?.stepMs ?? 60000);
    const delay = Math.max(250, nextAt - Date.now());
    nextTimer = setTimeout(() => refresh(), delay);
  }

  tfButtons.forEach(b=>b.addEventListener('click', ()=>{
    tfButtons.forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    timeframe = b.dataset.tf;
    if (nextTimer) clearTimeout(nextTimer);
    window.__tickStep = pickTickStep(timeframe);
    // reload series for new timeframe, then reschedule
    refresh();
  }));

  /* ===== Data fetching ===== */
  async function refresh(){
    const params = new URLSearchParams(location.search);
    const devMode = params.get('dev') === '1';
    const url = '/.netlify/functions/read-votes?tf=' + timeframe + (devMode ? '&includeSpam=1' : '');
    const r = await fetch(url, { cache:'no-store' });
    const j = await r.json();

    window.__tickStep = pickTickStep(timeframe);
    chart.data.labels = j.points.map(p=>p.t);
    chart.data.datasets[0].data = j.points.map(p=>p.v);
    chart.update();
    document.getElementById('current').textContent = '— ' + (j.current ?? 50) + '/100';

    // schedule next update exactly at the end of the next bucket
    scheduleNext(j.meta);
  }

  /* ===== Slider + color badge ===== */
  const slider = document.getElementById('slider');
  const sVal = document.getElementById('sVal');
  function setBadge(v){
    sVal.textContent = v;
    const badge = document.querySelector('.valueBadge');
    const c = v<40 ? '#ef4444' : (v>60 ? '#22c55e' : '#eab308');
    badge.style.borderColor = c + '55';
    badge.style.color = c;
  }
  setBadge(50);
  slider.addEventListener('input', e=> setBadge(e.target.value));

  /* ===== Vote (no chart refresh here) ===== */
  const msg = document.getElementById('msg');
  const btn = document.getElementById('voteBtn');

  async function voteOnce(value){
    const data = new FormData();
    data.append('form-name','vote');
    data.append('value', String(value));
    await fetch('/', { method:'POST', body:data });
  }

  async function vote(){
    btn.disabled = true; btn.classList.add('disabled'); btn.textContent = 'Voted ✓';
    const val = Number(slider.value);
    await voteOnce(val);
    msg.className='ok'; msg.textContent='Thanks for voting!';
    setTimeout(()=>{ msg.className='muted'; msg.textContent=''; btn.disabled=false; btn.classList.remove('disabled'); btn.textContent='Vote'; }, 1200);
    // no refresh here — chart updates at the next scheduled tick
  }
  btn.addEventListener('click', vote);

  /* ===== Dev spam (15–20 votes/sec) ===== */
  const params = new URLSearchParams(location.search);
  const devBox = document.getElementById('devBox');
  let spamTimer = null;
  if (params.get('dev') === '1') devBox.style.display = 'flex';

  document.getElementById('devStart')?.addEventListener('click', ()=>{
    if (spamTimer) return;
    spamTimer = setInterval(async ()=>{
      for (let i=0;i<Math.floor(1 + Math.random()*3);i++){
        const v = Math.floor(5 + Math.random()*90);
        voteOnce(v).catch(()=>{});
      }
      // no immediate chart refresh; rely on scheduler
    }, 60);
  });
  document.getElementById('devStop')?.addEventListener('click', ()=>{
    clearInterval(spamTimer); spamTimer = null;
  });

  // First draw + schedule next
  refresh();
</script>
</body>
</html>
